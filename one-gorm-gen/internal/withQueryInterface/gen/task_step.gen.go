// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package gen

import (
	"context"
	"database/sql"
	"strings"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"
	"gorm.io/gen/helper"

	"gorm.io/plugin/dbresolver"
)

func newTaskStep(db *gorm.DB, opts ...gen.DOOption) taskStep {
	_taskStep := taskStep{}

	_taskStep.taskStepDo.UseDB(db, opts...)
	_taskStep.taskStepDo.UseModel(&model.TaskStep{})

	tableName := _taskStep.taskStepDo.TableName()
	_taskStep.ALL = field.NewAsterisk(tableName)
	_taskStep.ID = field.NewInt32(tableName, "id")
	_taskStep.TaskID = field.NewInt32(tableName, "task_id")
	_taskStep.StepID = field.NewInt32(tableName, "step_id")
	_taskStep.Sort = field.NewInt32(tableName, "sort")
	_taskStep.CreateTime = field.NewTime(tableName, "create_time")
	_taskStep.UpdateTime = field.NewTime(tableName, "update_time")
	_taskStep.CreateUserID = field.NewString(tableName, "create_user_id")
	_taskStep.UpdateUserID = field.NewString(tableName, "update_user_id")
	_taskStep.Extra = field.NewString(tableName, "extra")
	_taskStep.PreStep = field.NewInt32(tableName, "pre_step")
	_taskStep.IsAutoNext = field.NewBool(tableName, "is_auto_next")

	_taskStep.fillFieldMap()

	return _taskStep
}

// taskStep 任务流-步骤表，标明该步骤应该在任务流的哪一步
type taskStep struct {
	taskStepDo taskStepDo

	ALL          field.Asterisk
	ID           field.Int32
	TaskID       field.Int32
	StepID       field.Int32
	Sort         field.Int32  // 用来标记同一task中step的顺序
	CreateTime   field.Time   // 创建时间
	UpdateTime   field.Time   // 更新时间
	CreateUserID field.String // 创建人
	UpdateUserID field.String // 创建人
	Extra        field.String
	PreStep      field.Int32 // 这一步的输入应该取哪一步的输出
	IsAutoNext   field.Bool  // 是否自动执行下一步

	fieldMap map[string]field.Expr
}

func (t taskStep) Table(newTableName string) *taskStep {
	t.taskStepDo.UseTable(newTableName)
	return t.updateTableName(newTableName)
}

func (t taskStep) As(alias string) *taskStep {
	t.taskStepDo.DO = *(t.taskStepDo.As(alias).(*gen.DO))
	return t.updateTableName(alias)
}

func (t *taskStep) updateTableName(table string) *taskStep {
	t.ALL = field.NewAsterisk(table)
	t.ID = field.NewInt32(table, "id")
	t.TaskID = field.NewInt32(table, "task_id")
	t.StepID = field.NewInt32(table, "step_id")
	t.Sort = field.NewInt32(table, "sort")
	t.CreateTime = field.NewTime(table, "create_time")
	t.UpdateTime = field.NewTime(table, "update_time")
	t.CreateUserID = field.NewString(table, "create_user_id")
	t.UpdateUserID = field.NewString(table, "update_user_id")
	t.Extra = field.NewString(table, "extra")
	t.PreStep = field.NewInt32(table, "pre_step")
	t.IsAutoNext = field.NewBool(table, "is_auto_next")

	t.fillFieldMap()

	return t
}

func (t *taskStep) WithContext(ctx context.Context) ITaskStepDo { return t.taskStepDo.WithContext(ctx) }

func (t taskStep) TableName() string { return t.taskStepDo.TableName() }

func (t taskStep) Alias() string { return t.taskStepDo.Alias() }

func (t taskStep) Columns(cols ...field.Expr) gen.Columns { return t.taskStepDo.Columns(cols...) }

func (t *taskStep) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := t.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (t *taskStep) fillFieldMap() {
	t.fieldMap = make(map[string]field.Expr, 11)
	t.fieldMap["id"] = t.ID
	t.fieldMap["task_id"] = t.TaskID
	t.fieldMap["step_id"] = t.StepID
	t.fieldMap["sort"] = t.Sort
	t.fieldMap["create_time"] = t.CreateTime
	t.fieldMap["update_time"] = t.UpdateTime
	t.fieldMap["create_user_id"] = t.CreateUserID
	t.fieldMap["update_user_id"] = t.UpdateUserID
	t.fieldMap["extra"] = t.Extra
	t.fieldMap["pre_step"] = t.PreStep
	t.fieldMap["is_auto_next"] = t.IsAutoNext
}

func (t taskStep) clone(db *gorm.DB) taskStep {
	t.taskStepDo.ReplaceConnPool(db.Statement.ConnPool)
	return t
}

func (t taskStep) replaceDB(db *gorm.DB) taskStep {
	t.taskStepDo.ReplaceDB(db)
	return t
}

type taskStepDo struct{ gen.DO }

type ITaskStepDo interface {
	gen.SubQuery
	Debug() ITaskStepDo
	WithContext(ctx context.Context) ITaskStepDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() ITaskStepDo
	WriteDB() ITaskStepDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) ITaskStepDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) ITaskStepDo
	Not(conds ...gen.Condition) ITaskStepDo
	Or(conds ...gen.Condition) ITaskStepDo
	Select(conds ...field.Expr) ITaskStepDo
	Where(conds ...gen.Condition) ITaskStepDo
	Order(conds ...field.Expr) ITaskStepDo
	Distinct(cols ...field.Expr) ITaskStepDo
	Omit(cols ...field.Expr) ITaskStepDo
	Join(table schema.Tabler, on ...field.Expr) ITaskStepDo
	LeftJoin(table schema.Tabler, on ...field.Expr) ITaskStepDo
	RightJoin(table schema.Tabler, on ...field.Expr) ITaskStepDo
	Group(cols ...field.Expr) ITaskStepDo
	Having(conds ...gen.Condition) ITaskStepDo
	Limit(limit int) ITaskStepDo
	Offset(offset int) ITaskStepDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) ITaskStepDo
	Unscoped() ITaskStepDo
	Create(values ...*model.TaskStep) error
	CreateInBatches(values []*model.TaskStep, batchSize int) error
	Save(values ...*model.TaskStep) error
	First() (*model.TaskStep, error)
	Take() (*model.TaskStep, error)
	Last() (*model.TaskStep, error)
	Find() ([]*model.TaskStep, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.TaskStep, err error)
	FindInBatches(result *[]*model.TaskStep, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.TaskStep) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) ITaskStepDo
	Assign(attrs ...field.AssignExpr) ITaskStepDo
	Joins(fields ...field.RelationField) ITaskStepDo
	Preload(fields ...field.RelationField) ITaskStepDo
	FirstOrInit() (*model.TaskStep, error)
	FirstOrCreate() (*model.TaskStep, error)
	FindByPage(offset int, limit int) (result []*model.TaskStep, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) ITaskStepDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (t taskStepDo) Debug() ITaskStepDo {
	return t.withDO(t.DO.Debug())
}

func (t taskStepDo) WithContext(ctx context.Context) ITaskStepDo {
	return t.withDO(t.DO.WithContext(ctx))
}

func (t taskStepDo) ReadDB() ITaskStepDo {
	return t.Clauses(dbresolver.Read)
}

func (t taskStepDo) WriteDB() ITaskStepDo {
	return t.Clauses(dbresolver.Write)
}

func (t taskStepDo) Session(config *gorm.Session) ITaskStepDo {
	return t.withDO(t.DO.Session(config))
}

func (t taskStepDo) Clauses(conds ...clause.Expression) ITaskStepDo {
	return t.withDO(t.DO.Clauses(conds...))
}

func (t taskStepDo) Returning(value interface{}, columns ...string) ITaskStepDo {
	return t.withDO(t.DO.Returning(value, columns...))
}

func (t taskStepDo) Not(conds ...gen.Condition) ITaskStepDo {
	return t.withDO(t.DO.Not(conds...))
}

func (t taskStepDo) Or(conds ...gen.Condition) ITaskStepDo {
	return t.withDO(t.DO.Or(conds...))
}

func (t taskStepDo) Select(conds ...field.Expr) ITaskStepDo {
	return t.withDO(t.DO.Select(conds...))
}

func (t taskStepDo) Where(conds ...gen.Condition) ITaskStepDo {
	return t.withDO(t.DO.Where(conds...))
}

func (t taskStepDo) Order(conds ...field.Expr) ITaskStepDo {
	return t.withDO(t.DO.Order(conds...))
}

func (t taskStepDo) Distinct(cols ...field.Expr) ITaskStepDo {
	return t.withDO(t.DO.Distinct(cols...))
}

func (t taskStepDo) Omit(cols ...field.Expr) ITaskStepDo {
	return t.withDO(t.DO.Omit(cols...))
}

func (t taskStepDo) Join(table schema.Tabler, on ...field.Expr) ITaskStepDo {
	return t.withDO(t.DO.Join(table, on...))
}

func (t taskStepDo) LeftJoin(table schema.Tabler, on ...field.Expr) ITaskStepDo {
	return t.withDO(t.DO.LeftJoin(table, on...))
}

func (t taskStepDo) RightJoin(table schema.Tabler, on ...field.Expr) ITaskStepDo {
	return t.withDO(t.DO.RightJoin(table, on...))
}

func (t taskStepDo) Group(cols ...field.Expr) ITaskStepDo {
	return t.withDO(t.DO.Group(cols...))
}

func (t taskStepDo) Having(conds ...gen.Condition) ITaskStepDo {
	return t.withDO(t.DO.Having(conds...))
}

func (t taskStepDo) Limit(limit int) ITaskStepDo {
	return t.withDO(t.DO.Limit(limit))
}

func (t taskStepDo) Offset(offset int) ITaskStepDo {
	return t.withDO(t.DO.Offset(offset))
}

func (t taskStepDo) Scopes(funcs ...func(gen.Dao) gen.Dao) ITaskStepDo {
	return t.withDO(t.DO.Scopes(funcs...))
}

func (t taskStepDo) Unscoped() ITaskStepDo {
	return t.withDO(t.DO.Unscoped())
}

func (t taskStepDo) Create(values ...*model.TaskStep) error {
	if len(values) == 0 {
		return nil
	}
	return t.DO.Create(values)
}

func (t taskStepDo) CreateInBatches(values []*model.TaskStep, batchSize int) error {
	return t.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (t taskStepDo) Save(values ...*model.TaskStep) error {
	if len(values) == 0 {
		return nil
	}
	return t.DO.Save(values)
}

func (t taskStepDo) First() (*model.TaskStep, error) {
	if result, err := t.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.TaskStep), nil
	}
}

func (t taskStepDo) Take() (*model.TaskStep, error) {
	if result, err := t.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.TaskStep), nil
	}
}

func (t taskStepDo) Last() (*model.TaskStep, error) {
	if result, err := t.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.TaskStep), nil
	}
}

func (t taskStepDo) Find() ([]*model.TaskStep, error) {
	result, err := t.DO.Find()
	return result.([]*model.TaskStep), err
}

func (t taskStepDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.TaskStep, err error) {
	buf := make([]*model.TaskStep, 0, batchSize)
	err = t.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (t taskStepDo) FindInBatches(result *[]*model.TaskStep, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return t.DO.FindInBatches(result, batchSize, fc)
}

func (t taskStepDo) Attrs(attrs ...field.AssignExpr) ITaskStepDo {
	return t.withDO(t.DO.Attrs(attrs...))
}

func (t taskStepDo) Assign(attrs ...field.AssignExpr) ITaskStepDo {
	return t.withDO(t.DO.Assign(attrs...))
}

func (t taskStepDo) Joins(fields ...field.RelationField) ITaskStepDo {
	for _, _f := range fields {
		t = *t.withDO(t.DO.Joins(_f))
	}
	return &t
}

func (t taskStepDo) Preload(fields ...field.RelationField) ITaskStepDo {
	for _, _f := range fields {
		t = *t.withDO(t.DO.Preload(_f))
	}
	return &t
}

func (t taskStepDo) FirstOrInit() (*model.TaskStep, error) {
	if result, err := t.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.TaskStep), nil
	}
}

func (t taskStepDo) FirstOrCreate() (*model.TaskStep, error) {
	if result, err := t.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.TaskStep), nil
	}
}

func (t taskStepDo) FindByPage(offset int, limit int) (result []*model.TaskStep, count int64, err error) {
	result, err = t.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = t.Offset(-1).Limit(-1).Count()
	return
}

func (t taskStepDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = t.Count()
	if err != nil {
		return
	}

	err = t.Offset(offset).Limit(limit).Scan(result)
	return
}

func (t taskStepDo) Scan(result interface{}) (err error) {
	return t.DO.Scan(result)
}

func (t taskStepDo) Delete(models ...*model.TaskStep) (result gen.ResultInfo, err error) {
	return t.DO.Delete(models)
}

func (t *taskStepDo) withDO(do gen.Dao) *taskStepDo {
	t.DO = *do.(*gen.DO)
	return t
}
